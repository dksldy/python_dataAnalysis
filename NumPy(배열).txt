** NumPy(Numerical Python) 
: 다차원 배열을 효율적으로 처리할수 있도록 해주는 라이브러리
 - 빠른 계산속도
 - 다양한 수학연산 제공
 - 다차원 배열(ndarray) 제공
 - 브로드캐스팅, 벡터 연산 지원
 - 머신 러닝 / 딥러닝 대부분의 기반이 NumPy 구조

** NumPy Array : ndarray
 - (N - 차원 배열) 다차원 배열을 표현할수 있는구조
 - 가장 핵심적인 데이터 구조
 - 모든 요소가 동일한 데이터 타입을 가짐
ex) data = np.array([1, 2, 3])

ndarray의 차원(Dimensions)
 - 1차원 (Vector) :
	- 단일 축을 가지는 선형 배열
	- 일반적인 데이터 리스트
	- shape : (N,)
 - 2차원 (Matrix) :
	- 행(Row)과 열(Column) 두 축을 가지는 표 형태
	- 스프레드 시트
	- shape : (Row, Col)
 - * 3차원 (Tensor) :
	- 깊이(Depth) 축이 추가된 다차원 구조
	- 컬러 이미지 : 높이, 너비, 색상
	- shape : (D, R, C)

* ndarray 핵심 속성 :
 - .ndim : 배열의 차원 수 반환
 - .shape : 배열의 형태를 튜플로 반환
 - .dtype : 배열에 저장된 요소의 데이터 타입 반환
 - .size : 배열의 요소 개수

ex)
 import numpy as np
 arr = np.array([[1,2,3,],[4,5,6]])

 print(f'ndim : {arr.ndim}')	=> 2
 print(f'shape : {arr.shape}')	=> (2,3)   #(행, 열)
 print(f'dtype : {arr.dtype}')	=> int
 print(f'dtype : {arr.size}')	=> 6

** NumPy 설치
 pip install numpy	# Python 설치 되어 있어야함
 
 설치 확인
 python
 >>> import numpy as np
 >>> print(np.__version__)

* ndarray 생성
 기본 array 생성
 - a = np.array([1,2,3])

 다차원 배열 생성
 - a = np.array( [ [1,2,3], [4,5,6], [...], ... ] )

 순차 배열 생성 => (시작, 끝값, 건너띄기)
 - a = np.arange(0, 10, 2)	# 0~9, step = 2
 - b = np. linspace(0, 1, 5)	# 0~1 구간을 5등분

 특정 값으로 채우면서 생성 => (행, 열) , ([특정값] = full)
 - a = np.zeros((2,3))	# 2x3 0 으로 채우기
 - b = np.ones((2,3))	# 1로 채우기
 - c = np.full((2,3),7)	# 7로 채우기
 - d = np.arange(0,10,1)	# (시작값, 끝값,증가값) => 끝값 은 + 1

** Indexing : 인덱스(위치) 를 사용하여 단일 요소의 값에 접근 하는 방법
 기본 인덱싱:
  각 차원(축)의 인덱스를 사용하여 단 하나의 특정 요소에 접근 방법
   - 1D (1차원) : 리스트와 동일, 하나의 인덱스 를 사용해 요소에 접근 => a[2]
   - 2D+ (2차원 이상) : 쉼표로 구분된 인덱스를 사용하여 각 차원의 위치를 지정하여 요소에 접근 => b[1,2,3]

* Slicing : 범위를 지정하여 배열이나 리스트의 연속적인 부분 집합을 추출하는 방법
    - 대상[시작 인덱스 : 끝 인덱스 : 간격]	=> 모두 생략 가능
           [생략시 0 : 생략시 배열의 끝(마지막인덱스 +1) : 생략시 1]
	ex )
	c = np.array([[1,2,3],[4,5,6],[7,8,9]])
	>>> c[ : , 0 : 1 ]	# => 대상[행(Slicing), 열(Slicing)]
	array([[1],
	       [4],
	       [7]])
	>>> c[ 0 : 3 : 2 , 0 : 2 ]
	array([[1, 2],
	       [7, 8]])

* Boolean Indexing : 특정 조건을 만족하는 요소들만 필터링 하여 추출할 때 사용
 ex)
	arr = np.array([10, 21, 30, 43, 50])
	result = arr[ arr > 25] => array([30, 43, 50])
 - 조건식을 배열에 적용, 각 요소가 조건을 만족하는지 여부를 담은 불리언 배열생성
 arr > 25 -> [False, False, True, True, True]
 - 불리언 배열을 원본 배열의 인덱스로 사용, True 위치의 요소만 선택되어 새로운 배열로 추출
 arr[arr > 25] -> [30, 43, 50]

백터화 연산 : 데이터 처리시 반복문을 사용하지 않고 배열 전체에 대해 연산을 적용하는 방식
 ex)
>>> n1 = np.array([1,2,3])
>>> n2 = np.array([4,5,6])
>>> print(n1+n2)
[5 7 9]
>>> print(n1*n2)
[ 4 10 18]
>>> print(n1**n2)
[  1  32 729]
>>> print(n2/n1)
[4.  2.5 2. ]

브로드 캐스팅 (Broadcasting) : (배열길이 동일해야함)
	크기가 다른 두 배열간에 연산 수행시, 더 작은 배열을 자동으로 확장하여, 
	두 배열의모양을 맞추어 연산을 수행
 a = np.array([1,2,3])
 b = 10
 print(a + b) => [11, 12, 13] # b = 10 => b [ 10, 10, 10 ]
 
 c = np.array([[1,2,3,], [4,5,6]])
 d = np.array([10,20,30])
 print(c + d) => [11,22,33],[14,25,36]

집계 함수와 Axis
 - 집계 함수 : 배열의 모든 요소나 특정 축(Axis)을 따라 연산을 수행
 - Axis(축) : 배열의 특정 차원
 ex)
 np.sum(arr, axis=0)	# => 행 더하기
 np.sum(arr, axis=1)	# => 열 더하기
 np.max(arr)		# => 전체 최대 값
 np.min(arr)		# => 전체 최소 값
 np.mean(arr)		# => 더한 값에 평균값


NumPy / ndarray / Indexing / Slicing / Boolean Indexing

https://u-n-joe.tistory.com/94 => Numpy 문제 모음집 (해답 포함)